##noty微系统

后台微系统职能：  
>- 负责组装模块（系统提供的模块和用户插件）
>- 负责模块之间的交互（类似事件驱动机制）
>- 启动noty

模块: 每个模块完成单一种类的后台工作，每个模块的结构描述：

> - 全局的id，入口配置，状态等，参考以前的插件系统
> - 生命周期继承入口：模块启动，卸载，重启，销毁的监听逻辑入口 
> - 模块的配置（一些功能参数设定）： 
>> 1. 提供json描述，自动在前台生成配置项，比如{name:'分页',type='number'}，后台对应的配置页面自动生成一个 input框,也可以描述checkbox这样有约束的配置（用户填错数字照成的bug可以减少）
>> 2. 自定义页面，比如文章管理这样复杂的页面，就直接提供页面地址
>> 3. 在后台对应文件进行配置，模块的配置项继承config类，提供setget,文件里直接写模块名.page=11

> - 对其他模块的服务
>  每个模块提供的事件模式相关的服务（重视交互性的一些功能，其他的交互直接查询数据库就能完成的，那就直接搞吧） 
>
> - 对页面的逻辑
> 主要就是包括页面发出请求去后台的逻辑，实现Controller即可，但最好模块的每个RequestMapping都加上模块id号 防止全局冲突
> - fast fix 功能，每个模块对于一个（系统约束的）java类位置，此java类可以对次模块的IOC内容进行AOP（系统提供的模块的扩展也就用此办法吧）
> - 用户自己写的逻辑， 应尽量引导使用IOC，方便其他用户fix


以上是后台微模块的基本描述， 一些系统模块，比如文章，缓存等可以在生命周期的时候强耦合一下servlet相关配置（毕竟是系统的模块），其他的用户模块由此基本可以满足基本需求


*后台* 微模和前台的交互 仅仅是
> - 前台发请求的后台对应
> - 一个简化的后台配置描述对应前台快速显示的功能（唯一的依赖点，初期的插件用户在后台修改配置文件，不需要前台）

后台不依赖前台，前台是主动，负责调用和串联页面逻辑，前台的微模块设计就请V想想。

Noty 前端设计

原则：
基于 Noty 的基本思想和后台设计，界面以简洁易用灵活为主。

思路:

	* 使用最简单直观的传统方式进行实现，既采用直观的 HTML 输出为主、尽量避免使用 JS 绘制元素来实现对界面的渲染。为了让代码更加的易读、方便后期功能的添加、减少维护，将不再使用 onhashchange， 至于 HTML5 History 也不暂不进行考虑。


	* 由于界面的多样化，为了方便整个布局的灵活调换，需把每一块独立的内容单独做成一个 widget。


	* 采用组合的方式，把每一个 widget 组合到页面中。


	* 对同一类页面，定义一个宏模版。在编写页面时，只需修改不同点即可。


	* 为减少兼容性带来的开发和避免对皮肤个性的地方所作出的限制，多皮肤之间不考虑公用 Noty 中的 ftl，js，css。


	* 静态资源合并&压缩、开启gzip。


	* ......


使用技术:
HTML(freemarker), CSS3,  JS(jQuery), HTML5(Tag, Canvas)

浏览器兼容：
Firefox, Chrome, IE 9/10/11









            
            
