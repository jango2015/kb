##noty微系统

后台微系统职能：  
>- 负责组装模块（系统提供的模块和用户插件）
>- 负责模块之间的交互（类似事件驱动机制）
>- 启动noty

模块: 每个模块完成单一种类的后台工作，每个模块的结构描述：

> - 全局的id，入口配置，状态等，参考以前的插件系统
> - 生命周期继承入口：模块启动，卸载，重启，销毁的监听逻辑入口 
> - 模块的配置（一些功能参数设定）： 
>> 1. 提供json描述，自动在前台生成配置项，比如{name:'分页',type='number'}，后台对应的配置页面自动生成一个 input框,也可以描述checkbox这样有约束的配置（用户填错数字照成的bug可以减少）
>> 2. 自定义页面，比如文章管理这样复杂的页面，就直接提供页面地址
>> 3. 在后台对应文件进行配置，模块的配置项继承config类，提供setget,文件里直接写模块名.page=11

> - 对其他模块的服务
>  每个模块提供的事件模式相关的服务（重视交互性的一些功能，其他的交互直接查询数据库就能完成的，那就直接搞吧） 
>
> - 对页面的逻辑
> 主要就是包括页面发出请求去后台的逻辑，实现Controller即可，但最好模块的每个RequestMapping都加上模块id号 防止全局冲突
> - fast fix 功能，每个模块对于一个（系统约束的）java类位置，此java类可以对次模块的IOC内容进行AOP（系统提供的模块的扩展也就用此办法吧）
> - 用户自己写的逻辑， 应尽量引导使用IOC，方便其他用户fix


以上是后台微模块的基本描述， 一些系统模块，比如文章，缓存等可以在生命周期的时候强耦合一下servlet相关配置（毕竟是系统的模块），其他的用户模块由此基本可以满足基本需求


*后台* 微模和前台的交互 仅仅是
> - 前台发请求的后台对应
> - 一个简化的后台配置描述对应前台快速显示的功能（唯一的依赖点，初期的插件用户在后台修改配置文件，不需要前台）

后台不依赖前台，前台是主动，负责调用和串联页面逻辑，前台的微模块设计就请V想想。

啦啦啦 








            
            
